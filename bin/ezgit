#!/usr/bin/env bash
# bin/ezgit

# This script may perhaps be just a tad bit overengineered, but it automates not only making backups
# of the remote git repo to both the local machine running the script, but as well as to the remote
# git repo.
# Although overengineered a bit, it provides functionality for everything I may want and has proven
# to be very useful in both bootstrapping new machines, and merging changes between the two.  (Also
# the more overengineered parts of the script were implemented as a learning experience for learning
# shell scripting and general programming experience, hence the sometimes unnecessary usage of
# functions.
#	TO-DO:
#		1.) Implement an automated GUI environment (preferably a nvim based program that
#		highlights discrepancies between versions of files.)
#		2.)
#
# Exits the script when an error is encountered to prevent potential damage from continuing to run.
####################################################################################################
#     Commenting this out for the time being until I figure out/take the time to omit certain      #
#   directories such as neovim plugins since they're causing permission denied errors and causing  #
#                                 the script to exit prematurely.                                  #
####################################################################################################
#set -e

####################################################################################################
###  Define global variables containing ANSI color codes, date and time, and the directories of  ###
###   the backups for both the remote (github repository) and local files (the files that are    ###
###              currently in-use on the machine this script is being executed on).              ###
####################################################################################################
# Define ANSI escape sequence color code variables.
CRESET='\033[0m'
CRED='\033[1;38;5;9m'
CGREEN='\033[1;38;5;10m'
CBLUE='\033[1;38;5;81m'
CULINE='\033[4m'

# Get current date and time for timestamp on logged archives.
DATE="$(date "+%m-%d-%Y")"	# Format of: MM-DD-YYYY		(ex: 01-20-2022).
TIME="$(date "+%I-%M%p")"	# Format of: HH-MM-[AM/PM]	(ex: 03-30PM).
# TIME="$(date "+%H-%M")"	# Old Format for time (0-24 hours, Minutes).

# Define a file for "log" files generated by this script; additionally, create a directory in the
# "/tmp" directory named "logfiles" if not already present just so that "/tmp" doesn't get overly
# cluttered with any potential files generated via running this script.
LOGFILEDIR="/tmp/logfiles/ezgit"
LOGFILE="${LOGFILEDIR}/ezgit-general_${DATE}_${TIME}.log"
LOGFILESTDERR="${LOGFILEDIR}/ezgit-error_${DATE}_${TIME}.log"
[[ ! -d "$LOGFILEDIR" ]] && mkdir -p "$LOGFILEDIR"

# Assign directory for both remote repo and local dotfiles for bzip2 tarballs to be stored within
# the local dotfile directory.
LOCALBACKUPS="/tmp/BACKUPS/Local/$DATE"
REMOTEBACKUPS="/tmp/BACKUPS/Remote/$DATE"

# Creates the directories for both remote git repository and local dotfiles to be held in bzip2
# tarballs.
[ ! -d "$LOCALBACKUPS" ] && mkdir -p "$LOCALBACKUPS"
[ ! -d "$REMOTEBACKUPS" ] && mkdir -p "$REMOTEBACKUPS"

####################################################################################################
###   Define list variables for: program dependencies that this script installs configuration    ###
### files to be used by; files and directories to be tracked (installed locally and or uploaded  ###
###      to github repository) via this script; and a list of explicitly defined files and       ###
### directories to NOT track (deletes copies in local git_dir of directories/files listed in the ###
### EXCLUSIONS list variable, then in another for loop unstages the tracking of said files as an ###
###                                   extra safety precaution)                                   ###
####################################################################################################

# List variable containing all of the package dependencies for both the script as well as the
# dotfile/config files for my setup.
DEPENDS=(	"bzip2"             \
			"curl"              \
			"fzf"               \
			"git"               \
			"neomutt"           \
			"neovim"            \
			"pv"                \
			"python3-pip"       \
			"python3-pygments"  \
			"rsync"             \
			"openssh"           \
			"tar"               \
			"tmux"              \
			"zsh"               \
		)

# Defines a list of files/folders to be deleted from the local directory before adding the contents
# of the pwd to git staged changes.
EXCLUSIONS=(".fzf"                                             \
			".fzf.*"                                           \
			"*.log"                                            \
			"*.netrwhist"                                      \
			"*.swp"                                            \
			"*.tdb"                                            \
			".config/Atom"                                     \
			".config/autostart"                                \
			".config/Bitcoin"                                  \
			".config/BraveSoftware"                            \
			".config/cantata"                                  \
			".config/chromium"                                 \
			".config/cni"                                      \
			".config/dconf/user"                               \
			".config/duc"                                      \
			".config/expressvpn"                               \
			".config/filelightrc"                              \
			".config/google-chrome"                            \
			".config/ghb"                                      \
			".config/glava"                                    \
			".config/keepassxc/*"                              \
			".config/libvirt"                                  \
			".config/lximage-qt/settings.conf"                 \
			".config/mpd/database"                             \
			".config/mpd/pid"                                  \
			".config/mpd/playlists/"                           \
			".config/mpd/state"                                \
			".config/mpd/sticker.sql"                          \
			".config/mopidy/"                                  \
			".config/MusicBrainz"                              \
			".config/neomutt/accounts/*"                       \
			".config/nicotine/"                                \
			".config/nvim/view"                                \
			".config/nvim/plugged/vim-orgmode"                 \
			".config/nvim/plugins/pathogen/MyFunctions/spell/" \
			".config/otpclient.cfg"                            \
			".config/oomox/*"                                  \
			".config/pcmanfm-qt/default/recent-files.conf"     \
			".config/projectM"                                 \
			".config/protonmail/*"                             \
			".config/QtProject.conf"                           \
			".config/ranger/bookmarks"                         \
			".config/ranger/history"                           \
			".config/ranger/tagged"                            \
			".config/spotify"                                  \
			".config/spotify-tui"                              \
			".config/thefuck"                                  \
			".config/torbrowser/"                              \
			".config/transmission"                             \
			".config/VPNetworkLLC/"                            \
			".config/vlc/vlc-qt-interface.conf"                \
			".config/wireshark"                                \
			".config/vlc/vlc-qt-interface.conf"                \
			".config/weechat/*"                                \
			".config/znt"                                      \
			".config/zsh/.zcompdump*"                          \
			".config/zsh/.zsh_history"                         \
			)

# Just a list of all the dotfiles, might integrate into some sort of parsing for auto git syncing.
FILELIST=(	".bashrc"                       \
			".config/"                      \
			".emacs.d/"                     \
			".fzf"                          \
			".fzf.bash"                     \
			".fzf.zsh"                      \
			".local/bin/ManualScripts/git/" \
			".nvim"                         \
			".oh-my-zsh"                    \
			".profile"                      \
			".terminfo"                     \
			".tmux.conf"                    \
			".vim"                          \
			".xinitrc"                      \
			".Xresources.d"                 \
			".Xresources"                   \
			".zprofile"                     \
			#"/etc/screenrc"                \
			#"/etc/zsh"                     \
			#".Xauthority"                  \ # Commenting out due to discrepancies between hosts.
			#"$HOME/.local"                 \
			# "bin/"                        \ # Commenting this out so it doesn't copy to $HOME dir.
		)

# Function/command to print out the FILELIST library, sort it into alpahbetical order, then
# encapsulate in quotes and adds a space and backslassh at the end of each line for better
# formatting.
function sortFILELIST(){
	test1=$(echo ${FILELIST[@]} | tr ' ' '\n' | sed -e 's/\(.*\)/"\1"/' -e 's/$/\ \\/')
	test2=($(echo ${FILELIST[@]} | sort -d -i -b | tr ' ' '\n' | \
		sed -e 's/\(.*\)/"\1"/' -e 's/$/\ \\/'))
	test3=$(echo ${FILELIST[@]} | sort -d -i -b | tr ' ' '\n' | \
		sed  -e 's/\(.*\)/"\1"/' -e 's/^/\t\t\t/' -e 's/$/\ \\/')
	test4="$test3"
	#test2=(
	#echo -n > /tmp/testingformatting
	echo "$test3" > /tmp/testingformatting
	#echo ${test2[@]} > /tmp/testingformatting
	#echo $test3
	#echo $test3 > /tmp/testingformatting
	#echo
	#echo ${FILELIST[@]}
	#diff <(echo "$test1") <(echo "$test2")
}

####################################################################################################
############################### Define the helper and main functions ###############################
####################################################################################################
# Defines a function to sleep for X seconds as first argument passed to it, and as a second argument
# print whatever text before the counter.
# Also defines a SLEEPTIME variable in case a [-nt|--no-timer] argument option is passed to the
# ezgit script.
# Default value for SLEEPTIME is 5 seconds, and if [-nt|--notimer] argument option is not passed to
# the script, the SLEEPFORX timer will default to 5; 0 seconds or no time will.
SLEEPTIME=5
function SLEEPFORX(){
	# Returns/exits this function if the time specified is 0 (when the -nt|--no-timer script option
	# is used).
	[[ "$1" -eq 0 ]] && return 0
	for i in `seq $1 -1 1`
	do
	    #echo -ne "\r$CRED$i"
	    echo -ne "\r$2 $CRED$i"
	    sleep 1
	    i=$((i-1))
	done
	echo -e $CRESET
	sleep 1
}

# Function that checks for missing dependencies and asks if the user would like to install them.
function CHECKDEPS(){
	for i in "${!DEPENDS[@]}"
	do
		#[[ ! $(command -v "${DEPENDS[$i]}") ]] && echo "Command \"${DEPENDS[$i]}\" is missing." \
		#	&& missingdepends+=("${DEPENDS[$i]}")
		[[ ! $(command -v "${DEPENDS[$i]}") ]] && MISSINGDEPENDS+=("${DEPENDS[$i]}")
	done

	# Checks if MISSINGDEPENDS list is empty, if not then missing dependencies were found.
	if [[ ${#MISSINGDEPENDS[@]} -ne 0 ]]
	then
		echo "Missing dependencies found: "
		for i in "${!MISSINGDEPENDS[@]}"
		do
			echo -e "${CRED}${MISSINGDEPENDS[$i]}${CRESET}"
		done

		# While loop to prompt a [Y/N] input from the user if they wish to install the missing
		# programs. If there are missing dependencies but non-critical ones, the user can proceed in
		# a "compatibility" mode.
		while [[ "$yn" != "y" && "$yn" != "n" ]]
		do
			read -e -n 1 -p "$(echo -e Would you like to install the dependencies? \
				["$CRED"Y"$CRESET"/"$CRED"n"$CRESET"]: ) " yn;

			# Sanitizing the read command input.
			yn="$(echo $yn | tr '[:upper:]' '[:lower:]')"
			echo

			# Exit if user selects "[n]o" to committing the changes.
			[[ "$yn" == "n" ]] && echo -e \
				"${CRED}Changes staged for commit have been made, but not committing.\nExiting..." \
				&& exit 1
		done
	fi
}

function USAGE(){
	echo -e "${CGREEN}Usage: ${CBLUE}./ezgit ${CRED}[ACTION]"
	echo -e "${CGREEN}ACTIONS:"
	# Install description:
	echo -e "\t ${CRED}-i | --install${CBLUE}\t\tPulls from remote git repo and" \
		"installs/updates local files."
	# Upload description:
	echo -e "\t ${CRED}-u | --upload${CBLUE}\t\tPulls remote repo to create a backup bz2" \
		"tarball, then uploads files\n\t\t\t\tlisted in the ${CGREEN}FILELIST${CBLUE} array list" \
		"to github repo."
	# Show differences description:
	echo -e "\t ${CRED}-d | --diff${CBLUE}\t\tRuns a ${CGREEN}\`${CRED}git diff${CGREEN}\`${CBLUE}" \
		"command between local and remote repo."
	# Help description:
	echo -e "\t ${CRED}-h | --help${CBLUE}\t\tPrint this help/usage page."
	# Print TODO message.
	echo -e "\n${CGREEN}TODO:\n\t${CRED}- Implement a function to compare remote and local files," \
		"for intelligent error protection,\n\t  rather than just creating archives of the entire" \
		"repository."
}

# Define the function that executes the commands to install files from the remote repository to the
# local machine.
function INSTALL(){
	# Change current git dir
	echo -ne $CRED && git init && echo -en $CRESET

	# Check if second script argument calls for either [-n|--no-backup] or [-f|--fast] options;
	# skip the backup if so.
	if [[ ! "$2" =~ ^-{1,2}[nf]{1} ]]
	then
		echo "Creating bzip2 tarbal archive of local git repo directory (pwd) in: "
		SLEEPFORX $SLEEPTIME "${CBLUE}$LOCALBACKUPS/local_git_dotfiles-$TIME.tar.bz2"

		# Updated this to include a slider progress bar via pv command and awk.
		tar -cf - --exclude='BACKUPS' --exclude='*.swp' . | pv -s $(du -sb . | \
			awk '{print $1}') | bzip2 > "$LOCALBACKUPS/local_git_dotfiles-$TIME.tar.bz2"
		echo
		echo "Now creating a bzip2 tarball of the config files locally installed in directory: "
		SLEEPFORX $SLEEPTIME "${CBLUE}$LOCALBACKUPS/`hostname`-$TIME.tar.bz2"
		tar -cjf "$LOCALBACKUPS/`hostname`-$TIME.tar.bz2" "${FILELIST[@]}"

		echo "Tarballs of both the local repo before updating, as well as the config files that"
		echo -e "were currently in-use on this system created and located in: \
			${CRED}$REMOTEBACKUPS${CRESET} directory."
		echo
		sleep 5
	fi
	echo "Syncing with remote git repo, then installing..."
	git pull origin master
	echo
	for i in "${FILELIST[@]}"
	do
		cp -r "$i" "$HOME/"
	done

	# Install zsh plugin manager (if not already installed/present in target system).
	#[[ ! -d "~/.config/zsh/Plugins/zsh-snap" ]] && \
	#	git clone --depth 1 -- https://github.com/marlonrichert/zsh-snap.git \
	#	~/.config/zsh/Plugins/zsh-snap


	# Checks to see if screenrc file exists, if so, also copies "/etc/screenrc" manually instead
	# of the "main install method" for loop since all that does is copies all the files from the
	# FILELIST list to the $HOME/* directory.
	if [[ -f "/etc/screenrc" ]]
	then
		cp "$0/etc/screenrc" "/etc/screenrc" && SCREENCP=1
		[[ $SCREENCP -ne 1 ]] && echo "Copying screenrc to \"/etc/screenrc\" failed." && \
			echo "Trying as root. (Press <Ctrl-C> to skip)" && \
			sudo cp "$0/etc/screenrc" "/etc/screenrc"
	fi

	#cp bin/colortest /usr/local/bin/colortest

	# Commenting out the below rsync method for now until I decide to get back around to working
	# on it to figure out how to get the exclusion option to read the list variables that
	# already exist in this script.
	#		Line directly below works, however a list variable substitution is very finicky.
	#			rsync -a --exclude './bin' --exclude './ezgit' --exclude './README.md' . ~
	#	RSYNCEXCLUDES=("/bin" "ezgit" "README.md")
	#	rsync -av --exclude-from='${RSYNCEXCLUDES[@]}' --progress . ~

	echo "Dotfiles installed, exiting..."
	exit 0
}

# Function for creating backups of the files modified by this script, whether they be from the
# remote (github) repository, or from the locally installed files (or at least the ones that are
# listed in the "FILELIST" list variable at the top of this script.
function createBackup(){
	### UNFINISHED ###
	# Options for backing up the LOCAL files.
	if [[ "$1" =~ ^-{1,2}[l]{1}[o]{0,1}[c]{0,1}[a]{0,1} ]]
	then
		echo "Creating bzip2 tarbal archive of local git repo directory (pwd) in: "
		SLEEPFORX $SLEEPTIME "${CBLUE}$LOCALBACKUPS/local_git_dotfiles-$TIME.tar.bz2"

		# Updated this to include a slider progress bar via pv command and awk.
		tar -cf - --exclude='BACKUPS' --exclude='*.swp' . | pv -s $(du -sb . | \
			awk '{print $1}') | bzip2 > "$LOCALBACKUPS/local_git_dotfiles-$TIME.tar.bz2"
		echo
		echo "Now creating a bzip2 tarball of the config files locally installed in directory: "
		SLEEPFORX $SLEEPTIME "${CBLUE}$LOCALBACKUPS/`hostname`-$TIME.tar.bz2"
		tar -cjf "$LOCALBACKUPS/`hostname`-$TIME.tar.bz2" "${FILELIST[@]}"

		echo "Tarballs of both the local repo before updating, as well as the config files that"
		echo -e "were currently in-use on this system created and located in: \
			${CRED}$REMOTEBACKUPS${CRESET} directory."
		echo
		sleep 5
	fi
}

# Writing a simple little function for easier/more efficient usage when using the [-f|--fast]
# option, so that it can just be called once and prompt the user for confirmation instead of writing
# this twice.
# This function should be called with the first/only argument being what purpose the main script is
# being used for (like [ [-i|--install] || [-u|--upload] ]) since it is negating the backup process
# and therefore the additional confirmation, this function does everything the: 
# [ [-f|--fast] || [-n|--no-backup] ] options do, but with additional confirmation, and thereby
# reducing instructions later on when calling these options.
function fastOption(){
	# Checks for at least one or two mandatory "-" followed by "n" or "f" for the [-f|--fast] or
	# [-n|--no-backup] options; if not present then do nothing (skip the "skipping" of creating
	# backups; or in other words, actually DO make backups).
	if [[ ! "$1" =~ ^-{1,2}[nf]{1} ]]
	then
		### UNFINISHED ###
		echo
	fi

}

# Main case switch statement.
case "$1" in
	-i|--install)
		# Change current git dir
		echo -ne $CRED && git init && echo -en $CRESET

		# Check if the [-f|--fast] or [-n|--no-backup] options were given; if so then call the
		# fastOption function. If the regex does not match for those options, then proceed normally.
		[[ "$2" =~ ^-{1,2}[nf]{1} ]] && fastOption "$2"

		# Check if second script argument calls for either [-n|--no-backup] or [-f|--fast] options;
		# skip the backup if so.
		if [[ ! "$2" =~ ^-{1,2}[nf]{1} ]]
		then
			echo "Creating bzip2 tarbal archive of local git repo directory (pwd) in: "
			SLEEPFORX $SLEEPTIME "${CBLUE}$LOCALBACKUPS/local_git_dotfiles-$TIME.tar.bz2"

			# Updated this to include a slider progress bar via pv command and awk.
			tar -cf - --exclude='BACKUPS' --exclude='*.swp' . | pv -s $(du -sb . | \
				awk '{print $1}') | bzip2 > "$LOCALBACKUPS/local_git_dotfiles-$TIME.tar.bz2"
 			echo
 			echo "Now creating a bzip2 tarball of the config files locally installed in directory: "
			SLEEPFORX $SLEEPTIME "${CBLUE}$LOCALBACKUPS/`hostname`-$TIME.tar.bz2"
 			tar -cjf "$LOCALBACKUPS/`hostname`-$TIME.tar.bz2" "${FILELIST[@]}"

 			echo "Tarballs of both the local repo before updating, as well as the config files that"
			echo -e "were currently in-use on this system created and located in: \
				${CRED}$REMOTEBACKUPS${CRESET} directory."
			echo
			sleep 5
		fi
		echo "Syncing with remote git repo, then installing..."
		git pull origin master
		echo
 		for i in "${FILELIST[@]}"
 		do
			# Copies all the files in the current directory--that are specified in the "$FILELIST"
			# list variable at the top of this script--into the current users home directory--and
			# logs any-and-all errors (STDERR) to a file located in:
			# "/tmp/ezgit_${DATE}_${TIME}.log" for a better way of tracking any potential "errors."
 			cp -r "$i" "$HOME/" 2>/tmp/ezgit_${DATE}_${TIME}.log
 		done
		# Checks to see if screenrc file exists, if so, also copies "/etc/screenrc" manually instead
		# of the "main install method" for loop since all that does is copies all the files from the
		# FILELIST list to the $HOME/* directory.
		if [[ -f /etc/screenrc ]]
		then
			cp "$PWD/etc/screenrc" "/etc/screenrc" && SCREENCP=1
			[[ $SCREENCP -ne 1 ]] && echo "Copying screenrc to \"/etc/screenrc\" failed." && \
				echo "Trying as root. (Press <Ctrl-C> to skip)" && \
				sudo cp "$PWD/etc/screenrc" /etc/screenrc
		fi

		#cp bin/colortest /usr/local/bin/colortest

		# Commenting out the below rsync method for now until I decide to get back around to working
		# on it to figure out how to get the exclusion option to read the list variables that
		# already exist in this script.
		#		Line directly below works, however a list variable substitution is very finicky.
		#			rsync -a --exclude './bin' --exclude './ezgit' --exclude './README.md' . ~
		#	RSYNCEXCLUDES=("/bin" "ezgit" "README.md")
		#	rsync -av --exclude-from='${RSYNCEXCLUDES[@]}' --progress . ~

		echo "Dotfiles installed, exiting..."
		exit 0
 		;;

####################################################################################################
####################################################################################################
####################################################################################################

 	-u|--upload)
		# Change current git dir
		echo -ne $CRED && git init && echo -en $CRESET
		# Check if second script argument calls for either [-n|--no-backup] or [-f|--fast] options;
		# skip the backup if so.
		if [[ ! "$2" =~ ^-{1,2}[nf]{1} ]]
		then
 			echo "Before uploading, the remote repo will be downloaded, compressed, and located at:"
			#echo -e "$CBLUE$REMOTEBACKUPS/Remote-Repo-$TIME.tar.bz2" && SLEEPFORX 5
			SLEEPFORX $SLEEPTIME "$CBLUE$REMOTEBACKUPS/Remote-Repo-$TIME.tar.bz2"

			# Clone the remote git repository into the Remote backups directory, then create a bzip2
			# archive of it and delete the cloned folder.
			git clone https://github.com/Andrew-Johnst/dotfiles.git "$REMOTEBACKUPS/dotfiles-$TIME"
 			tar -cjf "$REMOTEBACKUPS/Remote-Repo-${TIME}.tar.bz2" "$REMOTEBACKUPS/dotfiles-$TIME" \
				&>/dev/null
			yes | rm -r "$REMOTEBACKUPS/dotfiles-$TIME"
		fi

		# (Figured out that I need to delete all the files in the local git directory before staging
		# anything for a commit, since I had the drastic oversight of not realizing that I was only
		# copying files into this directory; so that when the files that are actually in use that I
		# want to push to my git repo, there are some that have been renamed or deleted, but still
		# remain in the git directory since it's a plain "cp" command).
		for i in "${FILELIST[@]}"
		do
			yes | rm -rf "$PWD/$i" 2>/dev/null
		done
	
		# Copies all of the files recursivley that are listed in the FILELIST array variable.
		# [Deprecated way using "cp" command. This has the undesired effect of not deleting files in
		# the git dotfile directory if they are deleted on the host that they are being copied from.
		# (Ex: a folder is deleted on this machine and that change should be made to the repository,
		# however only using a cp command without first deleting all files in the current directory
		# will keep deleted files)]
		# Below is the old/depreciated cp method, rsync is superior but it is currently only being
		# tested out right now and is WIP (actually going back to using this method since I don't
		# want to currently spend too much time trying to figure out how to get rsync to read get an
		# option argument to read a variable list contained within this script--and the point of
		# having the exclusion list was to have a centralized list while also being within the
		# script itself for maximum convenience, and creating a whole new file just for excluded
		# files is unnecessary).
 		for i in "${FILELIST[@]}"
 		do
			# Copies all the files in the home directory--that are specified in the "$FILELIST" list
			# variable at the top of this script--into this current directory (aka, the directory of
			# this ezgit script), and logs any and all errors (STDERR) to a file located in:
			# "/tmp/ezgit_${DATE}_${TIME}.log" for a better way of tracking any potential "errors."
 			cp -rf "$HOME/$i" . 2> "${LOGFILESTDERR}"
 		done
		# Checks for the "error" log file possibly generated after the file transfer; if it exists,
		# then prepend a message stating the date, time, and what file caused an error to arise.
		# (Doing this AFTER the for loop so it doesn't check each iteration for efficiency's sake,
		# and to only prepend this message once).
		#[[ "${LOGFILESTDERR}" ]] && [[ ! "$(grep '^This is an error log' ${LOGFILESTDERR})" ]] && \
		#	SEDMSG="This message was generated from the \'ezgit\' script with the: \[-u\|--upload\] option\.\n\n"
		#	sed -i '1s/^/This was generated from the: \[-u\|--upload\] option\.\n\n '


		# Checks to see if screenrc file exists, if so, also copies "/etc/screenrc" manually instead
		# of the "main install method" for loop since all that does is copies all the files from the
		# FILELIST list to the $HOME/* directory.
		if [[ -f "/etc/screenrc" ]]
		then
			cp "/etc/screenrc" "$PWD/etc/screenrc" && SCREENCP=1
			[[ $SCREENCP -ne 1 ]] && echo -n "Copying \"/etc/screenrc\" to " && \
				echo "\"$PWD/etc/screenrc\" failed." && \
				echo "Trying as root. (Press <Ctrl-C> to skip)" && \
				sudo cp "/etc/screenrc" "$PWD/etc/screenrc"
		fi

		# Below is the new rsync method.
		# Apparently, the issue of rsync not being able to read the exclude-from variable can be
		# solved by just setting a variable containing all the rsync options and just call that
		# instead.
		#	rsync -av --exclude-from="${EXCLUSIONS}" --progress "${FILELIST[@]}" .

		# Reinitialize git directory silently.
		git init &> /dev/null
		# Adds everything currently in directory to be staged in commit.
		git add -A .

		# Removes everything in the EXCLUSIONS list defined at the top of this script.
		for i in "${!EXCLUSIONS[@]}"
		do
			yes | rm -rf "${EXCLUSIONS[$i]}" &> /dev/null
			git rm -rf "${EXCLUSIONS[$i]}" &> /dev/null
		done

		git status
		# Using a while loop again to force y/n.
		while [[ "$yn" != "y" && "$yn" != "n" ]]
		do
			read -e -n 1 -p "$(echo -e Are the git status changes ok? \
				["$CRED"y"$CRESET"/"$CRED"n"$CRESET"]: ) " yn;

			# Sanitizing the read command input.
			yn="$(echo $yn | tr '[:upper:]' '[:lower:]')"
			echo

			# Exit if user selects "[n]o" to committing the changes.
			[[ "$yn" == "n" ]] && echo -e \
				"${CRED}Changes staged for commit have been made, but not committing.\nExiting..." \
				&& exit 1
		done
		read -e -p 'Name the commit: ' commitdesc
		# Change as of July 28, 2021 made to Github.com removed the ability to commit/make-changes to
		# repositories without some form of 2FA, so this command is changed to connect over SSH
		# using an SSH id keyfile locatd at: "~/.ssh/id_github" (as of 8-23-2021 only main drew@NAS
		# id keyfile has been added to github profile's ssh keyring).
		# (IMPORTANT!!!):
		# 	To use a specific SSH identify key file, it must be specified in the
		# 	"~/.ssh/config" file. For example/template in "~/.ssh/config" file:
		#
		#		Host github.com
		#			Hostname github.com
		#			IdentityFile ~/.ssh/id_github
		#			IdentitiesOnly yes
		#			# !!! SEE BELOW - "IdentitiesOnly" !!!
		#
		# 	!!! The "IdentitiesOnly yes" option is required to prevent the SSH default behaviour !!!
		# 	!!! of sending the identity file matching the default filename for each protocol.    !!!
		# 	!!! Example: if you have a file named "~/.ssh/id_rsa" it will be tried BEFORE the    !!!
		# 	!!! IdentityFile specified for the Host "gitserv" host ("~/.ssh/id_github") if the   !!!
		#   !!! "IdentitiesOnly yes" option is not specified.                                    !!!
		#git remote set-url origin git@github.com:Andrew-Johnst/dotfiles.git
		git remote add origin git@gitserv:Andrew-Johnst/dotfiles.git
		git commit -m "$commitdesc"
		git push origin master
		echo
		echo -e "${CGREEN}Successfully uploaded to git repo."
		echo
		exit 0
 		;;

####################################################################################################
####################################################################################################
####################################################################################################

	-d|--diff)
		echo "Prints difference between local and remote repos."
		git diff --stat --patch origin master
		;;

	-h|--help)
		USAGE
		exit 0
		;;

	*)
		[[ "$#" -ne 0 ]] && echo -e "${CBLUE}Argument: \"${CRED}$1${CBLUE}\" not understood."
		echo -ne "${CRESET}"
		USAGE
		exit 0
		;;
esac
