#!/usr/bin/env bash
#~/.config/zsh/functionrc

# Functionrc is an rc file used for housing all shell functions, used in conjunction with aliasrc
# file, and sourced within zshrc file.

# Command listed below shows all the currently assigned functions. (First one displays current
# functions with parenthesis, second command/line displays just the function names.
#	grep -E '[a-zA-Z0-9]+\(\)' functionrc | sed -e 's/[{ \t]//g' -e '/^#/d'
#	grep -E '[a-zA-Z0-9]+\(\)' functionrc | sed -e 's/[{ \t]//g' -e '/^#/d' -e 's/[\(\)]//g'

# Sets color variables for more [[[ A E S T H E T I C ]]]
local CR='\033[1;38;5;9m'
local CB='\033[1;38;5;117m'
local CG='\033[1;38;5;10m'
local CBL='\033[5m'
local CRE='\033[0m'
local CBBL=$(echo -e ${CB}${CBL})

# Unsets all functions in this file before redefining them.
# [WIP]

# Function to mkdir $1 and cd into it.
	mkcd(){
	    mkdir -p "$1" && cd "$1"
	}

# Alias for colored cat outputs (bat uses a man page type interface with scrolling, whereas pcat is
# just pygmentized cat standard output in the terminal).
	pcat(){
		[[ -f "$1" ]] && cat "$1" | pygmentize -f terminal256 -O style=monokai && exit 0
		pygmentize -f terminal256 -O style=monokai
	}
# Function to make `sudoedit` and `sudo -e` have propper syntaxing with filetype autodetect working.
#	function sudoedit {
#		SUDO_COMMAND="sudoedit $@" command sudoedit "$@"
#	}
# Function for using `sudo -e` just linking to sudoedit

# Function to git clone a directory, then cd into it.
	gcd(){
		git clone "$1" && cd "$(basename "$1" .git)"
	}
# Function to easily kill screen PIDs without having to manually type them out.
	sk(){
		local SCREENPIDS="$(screen -ls | sed -e 1d -e '$d' | cut -d '.' -f 1 | tr -d '\t')"
		echo $SCREENPIDS
	}
# Function to display the active network interface.
	nic(){
		# Old method, only prints active NIC interface.
		#echo $(ip -o -4 route get 1.1.1.1 | sed -nr 's/.*dev ([^\ ]+).*/\1/p')

        ############################################################################################
		########## New method, stores variables then prints them instead of a one-liner. ###########
		############### One-liner method is prefered, but using this method for now. ###############
		##### (Once a new one-liner is made, whichever method is most efficient will be used). #####
        ############################################################################################
		# ANSI Color Code Variables
		local CRED='\033[1;38;5;9m'
		local CGREEN='\033[1;38;5;10m'
		local CCYAN='\033[1;38;5;45m'
		local CPURP='\033[1;38;5;93m'			# Bold, Purple (#8700ff; rgb(135,0,255) hsl(71,100%,50%)).
		local CRESET='\033[0m'				# Resets ANSI Codes to default/none.
		# Get currently-active/in-use NIC device name.
		local DEVICE="$(ip -o -4 route get 1.1.1.1 | sed -nr 's/.*dev ([^\ ]+).*/\1/p')"
		# Get the LAN IP address of the currently-active/in-use NIC device.
		local DEVIP="$(ip -o -4 route get 1.1.1.1 | sed -nr 's/.*src ([^\ ]+).*/\1/p')"
		echo -e "${CGREEN}Active Network Interface is:\t${CRED}[$DEVICE${CRED}]"
		echo -en "${CRESET}"
		echo -e "${CCYAN}The IPv4 Address is:\t\t${CRED}[$DEVIP${CRED}]"

		#echo -e "${CGREEN}Active Network Interface is:     ${CRED}[$DEVICE${CRED}]"
		#echo -e "${CCYAN}The IP Address on ${CRED}[$DEVICE${CRED}]${CCYAN} is: ${CRED}[$DEVIP${CRED}]"
	}

# Colorization aliases.
	pycolor(){
		[[ -f "$1" ]] && pygmentize -f terminal256 -O style=monokai -g "$1" && exit 0
		[[ ! -f "$#" ]] && pygmentize -f terminal256 -O style=monokai -g -
	}

# Colorized Listing of the physical hard drive device, physical volume, volume group, and logical
# volume groups.
	disks(){
		# (This below command is no longer used since it does not account for LVMs, and this system
		# is installed on an LVM partition scheme, as well as multiple other LVM partitions).
		#		sudo parted -l | head -9 | pcat
		# Checks if root. Exit if not.
		#[[ "$EUID" -ne 0 ]] && echo -e "Please run this script as root/sudo.\nDoing nothing..." && return 1

		#sudo fdisk -l | sed -n -e '/\/dev\/sd[a-z]:/,/^$/p'
		#echo -e "\n\033[1;38;5;25m\t""Physical Volumes:"
		#	sudo pvs | sed -re 's/^[\t ]+PV[\ \t]+(.*)/Physical Volumes:\t\   \1/' -e 's/^[\t ]+(.*)/\t\t\1/'
		echo "#####################################################################################"
		echo "#### Physical Partitions and Storage/Block Devices (Only real/non-logical here): ####"
		echo "#####################################################################################"
		echo
		sudo fdisk -l /dev/sd[a-z] 2>/dev/null
		echo -e "\n\n"
		echo "#####################################################################################"
		echo "######## Physical Volumes (PVs), Volume Groups (VGs), Logical Volumes (LVMs): #######"
		echo "#####################################################################################"
		echo
		echo "Physical Volumes:"
		sudo pvs #| sed 's/'
		#echo -e "\n\033[1;38;5;205m\t""Volume Groups:"
		#echo -e "\n\033[1;38;5;205m\t""Volume Groups:"
		echo "Volume Groups:"
		sudo vgs
		#echo -e "\n\033[1;38;5;177m\t""Logical Volume Partitions:"
		#echo -e "\n\033[1;38;5;177m\t""Logical Volume Partitions:"
		echo "Logical Volumes:"
		sudo lvs
	}
	# Alias to pipe the entire contents of disks() function through pcat alias.
	alias disks='disks | plx'

# Function to display only the hidden files/folders. $1 argument can dictate whether or not to only
# show <-f|--files> or <-F|--folders>
	lh(){
		[[ -z "$@" ]] && ls -a | grep '^\.'
		if [[ "$#" -gt 1 ]]
		then
			[[ -d "$@" ]] && ls -a "$@" | grep '^\.'
		fi
	}

# Function to more easily add gpg keys (this is mainly so I don't have to remember the entire
# command and can just feed keys into this function.
	getaptkeyf(){
		# Checks if at least one argument is given, exits if not.
		[[ -z "$@" ]] && echo "Must specify keys to be added." && exit 1

		# Checks if the script version of this function is present. If found, forward the arguments
		# given to this function to the script; if not then continue running this function and
		# assume all argument parameters are all PUBKEY's requiring validation and importing.
		[[ -f "/usr/local/bin/getaptkey" ]] && \
			echo "The script file for this function has been found. Forwarding the arguments" \
			"from this function to the script." && echo && sudo /usr/local/bin/getaptkey "$@" \
			&& exit 0
		sudo apt-key adv --keyserver keys.gnupg.net --recv-keys "$@"
	}
# Function to redo previous command, but as sudo. ("Brute-force" method of doing this utilizing the
# history file so it can function independently of the shell limitations/syntaxing).
	s(){
		# This works independently of the shell being used; appears to not work if testing in shell
		# scripts since shell scripts are run in their own sub-shells and therefore have their own
		# history lists.
		[[ "$@" ]] && sudo "$@" && exit 0
		
		# Backticks must be used rather than a shell substitution with "$(<COMMAND>)" in conjunctio
		# with an eval command on the variable.
		lastcmd="`history | sed -e 's/^[0-9 ]*[ ]//' -e '$!d'`"
		# A "-s" option must be specified to sudo to keep the current shell variables/environment.
		sudo -s eval "$lastcmd"
	}

# Function to make running programs that would normally take over a shell session go to background
# and disown them so the shell the program was opened with can close without closing the program.
	q(){
		# Verify there are arguments (a command) to be run and disowned. Exit if not.
		[[ -z "$@" ]] && echo -e "No command specified to be hidden and disowned.\nExiting..." \
			&& exit 1
		[[ "$@" ]] && eval "$@" & disown
	}

# Function to print the Public IP address either currently being reported (aka, when a VPN/proxy
# connection is active and in-use), or the public/permenant IP address via a "-p" or "--permenant"
# option.
	getip(){
		[[ "$1" =~ '[-file]' ]]
	}

# Function to move into luks directory if already mounted and decrypted.
#cdintoluks(){
#	#[[ /dev/mapper/crypt/28683ecb-87c8-4622-9304-be9114ac6d7b &&
#	[[ ! "$1" ]] && exit 0
#	[[ sudo grep -q crypt /dev/disk/by-uuid/28683ecb-87c8-4622-9304-be9114ac6d7b ]] && cd /mnt/crypt
#}


# Reconnects to running tmux session; if multiple sessions found, list them and prompt for input on
# which to connect to.
#	Broken for right now. Will fix later.
#tmr(){
#	#tmux attach-session
#	tsessions="$(tmux list-session | wc -l )"
#	if [ "$tsessions" -gt 1 ]
#	then
#		tnum=0
#		while [[ ! $tnum =~ ^[0-9]{1,} || $tnum -lt $tsessions ]]
#		do
#			echo -e "${CR}There are multiple tmux sessions.${CRE}"
#			tmux list-sessions
#			echo -ne "${CR}Select which to attach to: ${CG}"
#			read tnum
#			echo
#			echo -e "${CR}Invalid Option: ${CBBL}$tnum${CRE}"
#		done
#		tmux attatch-session -t $tnum
#	fi
#}
