#!/usr/bin/env bash
#~/.config/zsh/functionrc

# Functionrc is an rc file used for housing all shell functions, used in conjunction with aliasrc
# file, and sourced within zshrc file.

# Command to find where the current functionrc file is located (regardless of what it is called).
#	find $ZDOTDIR -type f | grep -E "^*.zshrc$"
# egrep "frc|function|functionrc" "$(find $ZDOTDIR -type f | grep -E "^*.zshrc$")" | sed -e '/^#.*$/d'

# Command listed below shows all the currently assigned functions. (First one displays current
# functions with parenthesis, second command/line displays just the function names).
# The third one is POSIX compliant since it doesn't utilize extended REGEX in grep; however all work
# and the other two are more efficient.
#	grep -E '[a-zA-Z0-9]+\(\)' "$THISFILE" | sed -e 's/[{ \t]//g' -e '/^#/d'
#	grep -E '[a-zA-Z0-9]+\(\)' "$THISFILE" | sed -e 's/[{ \t]//g' -e '/^#/d' -e 's/[\(\)]//g'
#	sed -e 's/^[ \t]*//' -e '/^[#]/d' "$THISFILE" | grep "(){$" | tr -d [:punct:]

# Define a variable that contains the filepath of wherever this file is located (future-proofing
# in case this file moves in the future).
THISFILE="$( cd -- "$(dirname "$0")" >/dev/null 2>&1 ; pwd -P )/$(basename "$0")"

# Creates the directory "/tmp/tempfiles/" if it doesn't exist already. Used in both aliasrc and
# functionrc files.
[[ ! -d /tmp/tempfiles ]] && mkdir /tmp/tempfiles

####################################################################################################
##################################### ANSI Escape Code Colors. #####################################
##################### Sets color variables for more [{( A E S T H E T I C )}] ######################
####################################################################################################
local CR='\033[1;38;5;9m'
local CB='\033[1;38;5;117m'
local CG='\033[1;38;5;10m'
local CBL='\033[3m'
local CC='\033[1;38;5;14m'			# Bold, Cyan.
local CPU='\033[1;38;5;139m'		# Bold, Purple (#8700ff; rgb(135,0,255) hsl(71,100%,50%)).
local CP='\033[1;38;5;225m'			# Bold, Pink
local CT='\033[1;38;5;45m'			# Bold, Turquiose.
local CRE='\033[0m'					# Resets all ANSI color codes.

####################################################################################################
############################### Combination ANSI Escape Code Colors. ###############################
####################################################################################################
local CBBL=$(echo -e ${CB}${CBL})
local CRI=$(echo -e ${CR}${CBL})
local CGI=$(echo -e ${CG}${CBL})
local CPI=$(echo -e ${CPU}${CBL})

####################################################################################################

# Unsets all functions in this file before redefining them.
# [WIP]

# Function that declares all the functions in this file to the environment variable table and
# available to use with sudo.
function sf(){
	################################################################################################
	###   NOT CURRENTLY WORKING; FIX LATER. SOMETHING WRONG WITH NOT BEING ABLE TO DECLARE THE   ###
	###                                  FUNCTIONS TO SUDO.                                      ###
	################################################################################################
	# Since sudo cannot utilize these user defined functions, this block of code below first unsets
	# any previous declerations (to avoid logical errors via redundant or dead declarations); then
	# declares every function in this file that is not commented out.
	
	# For loop that for each function in this file, it is appended as a string into the
	# $ACTIVEFUNCTIONS list variable.
	for i in `sed -e 's/^[ \t]*//' -e '/^[#]/d' "$THISFILE" | grep "(){$" | tr -d '[:punct:]'`
	do
		#ACTIVEFUNCTIONS+=("$i")
		FUNCTION=$(declare -f "$i")
		sudo bash -c "$FUNCTION; "$i""
		#unset -f "$i"
		#sudo bash -c "declare -f "$i""
	done #| tee "/tmp/$USER-functions-`date '+%m-%d-%y_%H-%M-%S'`"
}

# Function to mkdir $1 and cd into it.
function mkcd(){
	#[[ "$1" =~ ^
    mkdir -p "$1" && cd "$1"

	#exe "normal o#".expand('%:p')."\r# " | startinsert!

}

# Alias for colored cat outputs (bat uses a man page type interface with scrolling, whereas pcat is
# just pygmentized cat standard output in the terminal).
function pcat(){
	#[[ -f "$1" ]] && { cat "$1" | pygmentize -f terminal256 -O style=monokai } || \
	#	pygmentize -f terminal256 -O style=monokai

	[[ -f "$1" ]] && cat "$1" | pygmentize -f terminal256 -O style=monokai && return 0
	pygmentize -f terminal256 -O style=monokai

}

# Another (Manually written function to colorize STDOUT and STDERR), but setting `set o pipefail`
# [Taken from this answer from stackoverflow]:
#	https://stackoverflow.com/a/16178979
#colorization()(set -o pipefail;"$@" 2>&1>&3|sed $'s,.*,\033[31m&\033[m,'>&2)3>&1
#color()(set -o pipefail;"$@" 2>&1>&3|sed $'s,.*,\e[31m&\e[m,'>&2)3>&1

####################################################################################################

# Function to make `sudoedit` and `sudo -e` have propper syntaxing with filetype autodetect working.
#	function sudoedit {
#		SUDO_COMMAND="sudoedit $@" command sudoedit "$@"
#	}
# Function for using `sudo -e` just linking to sudoedit

# Function to git clone a directory, then cd into it.
function gcd(){
	# If there is a second argument; verify that the parent directory exists regardless of if the
	# path/argument supplied in the second argument is the full path or relative path. Then name the
	# output git directory the second argument in either the current directory or wherever path
	# specified.
	# If no second argument is specified, just use the $PWD.
	[[ -z "$2" ]] && local OUTPUTDIR="$PWD/`basename "$1" .git`"
	[[ -d "$(realpath '`dirname "$2"`' 2>&1 >/dev/null )" ]] && local OUTPUTDIR="$2"
	git clone "$1" "$OUTPUTDIR"
	cd "$OUTPUTDIR"
	#cd "$(basename "$1" .git)"
}

# Function to easily list screen PIDs numbers.
function screenpids(){
	local SCREENPIDS="$(screen -ls | sed -e '1d;$d' -e 's/^[ \t]*//' -e 's/\..*$//')"
	echo $SCREENPIDS
	# This is the old version which uses multiple commands through pipes via STDIN/STDOUT.
	#local SCREENPIDS="$(screen -ls | sed '1d;$d' | cut -d '.' -f 1 | tr -d '\t')"
	#	Below is broken/not working [11-12-2021 1:34PM].
	#	screen -ls | sed -e '1d;$d' -e 's/^[ \t]*//' -e 's/(.*)\.(\w.*)/\1\ \2/g'
}; alias sp='screenpids'

# Changed the lx aliases into functions (certain itterations/variations on it are still just
# aliases--located in aliasrc file--but with options, so it has more flexibility and funcitonality
# like giving an option to the less command.
#	lx(){
#
#	}
# Function to print the Public IP address either currently being reported (aka, when a VPN/proxy
# connection is active and in-use), or the public/permenant IP address via a "-p" or "--permenant"
# option.
function ips(){
	#[[ "$1" =~ '[-file]' ]]
	#[[ "$1" =~ '?[--]
	#local CURRENTIP=`curl -s icanhazip.com`
	#local CURRENTIP="$(curl -s icanhazip.com)"
	curl -s icanhazip.com
	#local PRIMARYLANIP="$(ip -o -4 route get 1.1.1.1 | sed -nre \
	#	"s/\x1B\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g" -e 's/.*src ([^\ ]+).*/\1/p')"
	#local PRIMARYNIC="$(ip -o -4 route get 1.1.1.1 | sed -nr 's/.*dev ([^\ ]+).*/\1/p')"

	##ALLLANIPS+=("$(sudo ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' \
	##	| grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1')")

	#echo "List of all LAN IP addresses, including the primary WAN public IP address:"
	#echo "        Public ${CR}WAN${CRE} IP: [${CR}$(curl -s icanhazip.com)${CRE}]"
	#echo "Primary/Active ${CB}LAN${CRE} IP: [${CB}$PRIMARYLANIP${CRE}]" \
	#	 "on ${CG}NIC${CRE}: $PRIMARYNIC ${CRE}"
	#echo "Active IP addresses on localhost are:"
	#for i in "${#ALLLANIPS[@]}"
	#do
	#	#echo "                                     [${CR}${ALLLANIPS[$i]}${CRE}]"
	#	#echo "${ALLLANIPS[$i]}"
	#	echo a
	#done
	#sudo ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1' | grep -v "$(ip -o -4 route get 1.1.1.1 | sed -nre  "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g" -e 's/.*src ([^\ ]+).*/\1/p')"

	# Adding these below commands here since eventually the usage of gathering IPs *SHOULD* be
	# achieved via a function for more robust capabilities and all in a single function (with
	# parameters to determine what values to return) rather than multiple aliases each
	# containing the same--or slight variation of one--command.

	# This below command displays all "ACTIVE" LAN IP addresses, omitting IP gateways, loopback,
	# netmask, etc. and only displaying active LAN IPs assigned to any/all of the localhost's
	# NICs.
	#	ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' \
	#	| grep -v '127.0.0.1' 

	# Below command gets the currently active/main NIC's LAN IP address. The second--or in the
	# ordering of how this command had to be written to ommit an additional sed-pipe
	# command--sed script strips any ANSI escape codes (in the aliasrc file, the ip command has
	# the "color" option set to always and that proves undesirable for
	# scripting/output-redirection purposes) and outputs only the active NICs LAN IP address
	# without disabling the aliasrc's ip command color option.
	#	ip -o -4 route get 1.1.1.1 | sed -nre  "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g" \
	#	-e 's/.*src ([^\ ]+).*/\1/p'

	# Below is the conjoined command between the previous two commands, that displays ONLY the
	# non-main NIC LAN IP address(es), while stripping away any ANSI escape codes and outputing
	# rawtext values to STDOUT.
	#	ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' \
	#	| grep -v '127.0.0.1' | grep -v "$(ip -o -4 route get 1.1.1.1 | sed -nre \
	#	"s/\x1B\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g" -e 's/.*src ([^\ ]+).*/\1/p')"


}

# Function to display the active network interface.
function nic(){
	# Old method, only prints active NIC interface.
	#echo $(ip -o -4 route get 1.1.1.1 | sed -nr 's/.*dev ([^\ ]+).*/\1/p')

    ############################################################################################
	########## New method, stores variables then prints them instead of a one-liner. ###########
	############### One-liner method is prefered, but using this method for now. ###############
	##### (Once a new one-liner is made, whichever method is most efficient will be used). #####
    ############################################################################################

	# Get currently-active/in-use NIC device name.
	local DEVICE="$(ip -o -4 route get 1.1.1.1 | sed -nr 's/.*dev ([^\ ]+).*/\1/p')"
	# Get the LAN IP address of the currently-active/in-use NIC device.
	local DEVIP="$(ip -o -4 route get 1.1.1.1 | sed -nr 's/.*src ([^\ ]+).*/\1/p')"
	local WANIP=$(ips)
	echo -e "${CR}The Currently Active Network Interface is:\t${CR}[$DEVICE${CR}]"
	echo -en "${CRE}"
	echo -e "${CC}The ${CPI}LAN${CRE}${CC} IPv4 Address on that NIC is:\t\t${CR}[$DEVIP${CR}]"
	echo -e "${CC}The ${CGI}WAN${CRE}${CC} IPv4 Address on that NIC is currently:" \
		"\t${CR}[${CG}${WANIP}${CR}]"

	#echo -e "${CGREEN}Active Network Interface is:     ${CRED}[$DEVICE${CRED}]"
	#echo -e "${CCYAN}The IP Address on ${CRED}[$DEVICE${CRED}]${CCYAN} is: ${CRED}[$DEVIP${CRED}]"
}

# Function (only one command but too large/cumbersome to have in a single alias) to verify that the
# tor system service is running.
function checktor(){
	#VALIDCONN="$(curl --socks5 localhost:9050 --socks5-hostname localhost:9050 -s \
	#	https://check.torproject.org/ | cat | grep -m 1 Congratulations | xargs)"
	#echo -e "${CB}Current ${CPU}[${CG}Tor${CPU}] ${CPU}[${CR}IPv4${CPU}]${CB} Address: ${CC}
	curl --socks5 localhost:9050 --socks5-hostname localhost:9050 -s \
		https://check.torproject.org/ | cat | grep -m 1 Congratulations | xargs
	#[[ -z "$VALIDCONN" ]] && echo -e "Connection to the Tor Network is:" \
	#	"${CPU}[${CR}Disconnected${CPU}]"
}

# Colorization aliases.
function pycolor(){
	[[ -f "$1" ]] && pygmentize -f terminal256 -O style=monokai -g "$1" && exit 0
	[[ ! -f "$#" ]] && pygmentize -f terminal256 -O style=monokai -g -
}

# Colorized Listing of the physical hard drive device, physical volume, volume group, and logical
# volume groups.
function disks(){
	# TO-DO: add--or rather inject the data--from the "hddtemp" program into the pre-exisiting
	# STDOUT data received from the "fdisk" command.

	#sudo fdisk -l | sed -n -e '/\/dev\/sd[a-z]:/,/^$/p'
	#echo -e "\n\033[1;38;5;25m\t""Physical Volumes:"
	#sudo pvs | sed -re 's/^[\t ]+PV[\ \t]+(.*)/Physical Volumes:\t\   \1/' -e 's/^[\t ]+(.*)/\t\t\1/'

	echo "#####################################################################################"
	echo "#####################################################################################"
	echo "### [Physical Partitions and Storage/Block Devices (Only real/non-logical here).] ###"
	echo "#####################################################################################"
	echo "#####################################################################################"
	echo
	echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
	# Check if there are any NVMe drives (following the naming convention of:
	# "/dev/nvme[0-9]n[0-9]p[0-9]" for example: "/dev/nvme0n1p1") and display any/all drives
	# present/detected; hide results if not.
	#	[[ "$(ls /dev/nvme[0-9]n[0-9] 2>/dev/null)" ]] && \	# (Old "one-line" conditional solution).
	if [ "$(ls /dev/nvme[0-9]n[0-9] 2>/dev/null)" ]
	then
		echo
		echo "#####################################################################################"
		echo "################################ NVMe M.2 SSD Drives ################################"
		echo "#####################################################################################"
		sudo fdisk -l /dev/nvme[0-9]n[0-9] 2>/dev/null | cat -s
		echo 
		echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
	fi

	# Check if there are any "traditional" drives (following the naming convention of:
	# "/dev/[s|h]d[a-z][0-9]" for example: "/dev/sda1") and display any/all drives
	# present/detected; hide results if not.
	#	[[ "$(ls /dev/?d[a-z] 2>/dev/null)" ]] && \		#(Old "one-line" conditional solution).
	if [ "$(ls /dev/?d[a-z] 2>/dev/null)" ]
	then
		echo
		echo "#####################################################################################"
		echo "####################### Regular/Traditional Hard Disk Drives. #######################"
		echo "#####################################################################################"
		echo 
		sudo fdisk -l /dev/?d[a-z] 2>/dev/null | cat -s
		echo
		echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
	fi

	# Check if any mdadm RAID disks are present, display them if so and ommit the entire section
	# if not.
	#	[[ "$(ls /dev/md[0-9]* 2>/dev/null)" ]] && \		#(Old "one-line" conditional solution).
	if [ "$(ls /dev/md[0-9]* 2>/dev/null)" ]
	then
		echo
		echo "#####################################################################################"
		echo "################################# RAID Arrays/Disks #################################"
		echo "#####################################################################################"
		sudo fdisk -l /dev/md[0-9]* 2>/dev/null | cat -s && \
		echo 
		echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		echo 
		sudo df -aTh | sed '/\/sys*\|\/run*\|\/proc*/d'
		echo 
		echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
	fi

	# Show any LVM type devices.
	echo
	echo "#####################################################################################"
	echo "######## Physical Volumes (PVs), Volume Groups (VGs), Logical Volumes (LVMs). #######"
	echo "#####################################################################################"
	# Display the current Physical Volumes (PV's).
	echo "Physical Volumes:"
	echo
	sudo pvs
	echo
	echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
	# Display the current Volume Groups (VG's).
	echo "Volume Groups:"
	echo
	#echo -e "\n\033[1;38;5;205m\t""Volume Groups:"
	sudo vgs
	echo
	echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
	# Display the current Logical Volumes (LVM's).
	echo "Logical Volumes:"
	echo
	#	echo -e "\n\033[1;38;5;177m\t""Logical Volume Partitions:"
	sudo lvs
	echo
	echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
	# Display currently mounted drives/partitions/volumes.
	echo
	echo "#####################################################################################"
	echo "################ Currently Mounted Drives, Partitions, Volumes, etc. ################"
	echo "#####################################################################################"
	sudo df -h
} 2>/dev/null
# Adding a "2>/dev/null" at the end of the function definition to hide any errors if any drive
# typs are not present/detected, and thereby muting any errors from displaying.

# Alias to pipe the entire contents of disks() function through pcat alias.
alias disks='disks | plx'
[[ ! $(command -v pcat) ]] && alias disks='disks | less -X'

# Function to display only the hidden files/folders. $1 argument can dictate whether or not to only
# show <-f|--files> or <-F|--folders>
function lh(){
	[[ -z "$@" ]] && ls -a | grep '^\.'
	if [[ "$#" -gt 1 ]]
	then
		[[ -d "$@" ]] && ls -a "$@" | grep '^\.'
	fi
}

# Function to more easily add gpg keys (this is mainly so I don't have to remember the entire
# command and can just feed keys into this function.
function getaptkeyf(){
	# Checks if at least one argument is given, exits if not.
	[[ -z "$@" ]] && echo "Must specify keys to be added." && exit 1

	# Check for a [-k|--key|--key-only] option which will only lookup the gpg key on the keyserver
	# and then exit without adding it.
	([[ "$1" == "-k" ]] || [[ "$1" == "--key" ]] || [[ "$1" == "--key-only" ]]) && \
		gpg --keyserver hkp://keyserver.ubuntu.com:80 --search "${@:2}" && exit 0

	# Checks if the script version of this function is present. If found, forward the arguments
	# given to this function to the script; if not then continue running this function and
	# assume all argument parameters are all PUBKEY's requiring validation and importing.
	[[ -f "/usr/local/bin/getaptkey" ]] && \
		echo "The script file for this function has been found. Forwarding the arguments" \
		"from this function to the script." && echo && sudo /usr/local/bin/getaptkey "$@" \
		&& exit 0
	sudo apt-key adv --keyserver keys.gnupg.net --recv-keys "$@" \
		|| sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys "$@"
}

### (NEED TO UPGRADE THIS FUNCTION LATER SINCE THE ABOVE "getaptkeyf" IS NOW DEPRECATED AND NOW GPG
### --DEARMOR AND [/etc/apt/trusted.d/*] IS WHERE ALL THE GPG KEYS ARE STORED).
# Function to sorta streamline the new way of importing gpg keys for apt.
function aptgpgkey(){
	# Currently just disabling this function for now, as it needs some testing.
	return 0
	set -e
	[[ "$#" -eq 0 ]] && echo "Please either provide a *.gpg or *.key file, or pipe it with STDIN." \
		&& exit 1
	[[ -f "$1" ]] && ([[ "$1" == "*.key" ]] || [[ "$1" == "*.gpg" ]]) && \
		NAME="$(basename -s .key -s .gpg "$1")" && FILENAME="$1"
	
	sudo "$(cat "$FILENAME" | gpg --dearmor > "/usr/share/keyrings/$NAME-archive.gpg")"
	sudo install -o root -g root -m 644 \
		"/usr/share/keyrings/$NAME-archive.gpg" /etc/apt/trusted.gpg.d/

}

# Function to redo previous command, but as sudo. ("Brute-force" method of doing this utilizing the
# history file so it can function independently of the shell limitations/syntaxing).
function SS(){
	# This works independently of the shell being used; appears to not work if testing in shell
	# scripts since shell scripts are run in their own sub-shells and therefore have their own
	# history lists.
	[[ "$@" ]] && sudo "$@" && exit 0
	
	# Backticks must be used rather than a shell substitution with "$(<COMMAND>)" in conjunctio
	# with an eval command on the variable.
	lastcmd="`history | sed -e 's/^[0-9 ]*[ ]//' -e '$!d'`"
	# A "-s" option must be specified to sudo to keep the current shell variables/environment.
	sudo -s eval "$lastcmd"
}

# Function to make running programs that would normally take over a shell session go to background
# and disown them so the shell the program was opened with can close without closing the program.
function q(){
	# Verify there are arguments (a command) to be run and disowned. Exit if not.
	[[ -z "$@" ]] && echo -e "No command specified to be hidden and disowned.\nExiting..." \
		&& return 1

	# Assign the raw output (omitting STDERR if file-not-found to avoid logic-error) to a
	# variable that contains the absolute path of the command/program/script tryign to be
	# executed.
	PROGRAMPATH=`which $1` 1>/dev/null

	# Checks if the first argument passed to this function is a script/program/executable-file
	# before continuing and exits if not; if so, then every variable/string/word proceeding the
	# first argument is treated as options for that specific program.
	# ("-f" is shorthand for check-if-file-exists, "-x" checks if file exists and is executable).
	[[ ! -f "$PROGRAMPATH" ]] && echo -e \
		"Program/script \"$1\" has no path, therefore cannot be located.\nExiting..." && exit 1

	# This line below with the written sequence of routing to /dev/null and "& disown" is the
	# proper order and program syntax to send all STDOUT (like shell output log from a QT
	# application like nicotine++) to /dev/null and frees up the shell.
	# (A method that allows for tab_auto-completion with this function is greatly desired but
	# for the time being [10-5-2020 5AM]).
	[[ "$PROGRAMPATH" ]] && shift 1 && "$PROGRAMPATH" "$@" &>/dev/null & disown

	# Commenting these lines below out for testing (10-5-2020 5AM).
	#	[[ "$@" ]] && eval "$@" &>/dev/null & disown
	#	[[ "$@" ]] && eval "$@" &>/dev/null
	#	[[ "$@" ]] && eval "$@" & disown #&>/dev/null
}


# Functions for pandoc conversions used in conjunction with aliases from aliasrc file.
function pdocconv(){
	# Checks if function is called to convert Markdown to PDF.
	[[ "$1" == "md2pdf" ]] && CONVTYPE="md2pdf"
	[[ ! -f "$2" ]] && echo -e "${CR}$2${CRE} not a file." && exit 1
	FILENAME="$3"
	[[ -z "$3" ]] && FILENAME="$(echo "$2" | cut -f 1 -d '.').pdf"
	pandoc "$2" --pdf-engine=pdfroff -o "$FILENAME"

}

# Function to open a vim file titled as the date+time in the directory /tmp/tempfiles. Just for
# easier access to these files (despite the whole point of this function being to quickly create a
# file typically to test something out) an environment variable will be set to the last opened file
# opened with this function. Also an option to display a list of files in this directory and their
# last modification date and time.
function vtmp(){
	local DATETIME="`date '+%m-%d-%Y_%H-%M-%S%p'`"
	local TEMPFILEDIR="/tmp/tempfiles/zsh/"
	[[ -z "${1}" ]] && local TMPFILENAME="${DATETIME}"
	[[ -e "${1}" ]] && local TMPFILENAME="${1}"
	#export LASTVTMPFILE="`date '+%m-%d-%Y_%H-%M-%S%p'`"
	"${EDITOR}" "${TMPFILENAME}"
	echo -e "${CR}The tempfile is: ${CC}${TMPFILENAME}${CRE}"
}

# Function taken from a stackexchange post for a "hack" to be able to open "links" or "hypertext" in
# man pages in the pager (currently set to the `less` commands with some additional settings).
#	https://unix.stackexchange.com/a/381182/401241



# Function to create a bzip2 tar file while utilizing pbzip2 (a bzip2 program that utilizes
# multithreading/parallel-processing for faster times; if pbzip2 isn't installed, use bzip2; if
# bzip2 is missing, use XZ since LZMA is rather standard for Linux archives). This function also
# parses arguments passed to it as options to choose the compression method or (TODO) use a
# curses/ncurses progress window.
# USAGE: "tarp {TAR-FILENAME} {FILE(S) or DIRECTORY}"
function tarp(){
	# Checks that valid (this check specifically checks for ANY) input was received.
	[[ "$#" ]] && echo -e "${CR}Either invalid or no arguments passed." \
		"\n${CG}Read the description of this function in the functionrc file." \
		"\n${CR}Doing nothing and Exiting..." && exit 1

	# Checks that both variables are valid files/directories.
	for i in "$@"
	do
		[[ ! -f "$i" && ! -d "$i" ]] && echo -e "${CR}Invalid file/directory variable:\"$i\"" \
			"given." && return 1
	done

	# Checks if pbzip2 is installed, prefer that over bzip2 if installed. 
	local COMPMETHOD="pbzip2 -9"
	[[ ! "$(command -v "pbzip2")" ]] && local COMPMETHOD="bzip2 -9"
	# Checks that pv is installed, exit if it isn't installed.
	[[ ! "$(command -v "pv")" ]] && \
		echo -e "${CR}WARNING!!!\n${CRE}Command \"${CG}pv${CRE}\" not found, therefore," \
		"\n${CR}Exiting..." && return 1

	# Executing the compression and using the program pv and du to show a progress line.
	tar cf - "$2" -P | pv -s $(du -sb "$2" | awk '{print $1}') | eval $COMPMETHOD > "$1"
}

# Function to show progress deletion of files using rsync (or perl since it's benchmarks are faster;
# only used if perl is installed/useable). This function is useful for when deleting large
# directories and/or directories with a very large amount of files of small/average size but the
# sheer amount of files causes a slow execution).
function rmf(){
	# Check for which program to use. Use rm command if neither perl nor rsync are accessible.
	[[ ! "$(command -v "perl")" ]] && local USERSYNC=1
	[[ ! "$(command -v "rsync")" ]] && unset USERSYNC && local USERM=1
	# Temporarily adding this line below to manually set function to use rm.
	#local USERM=1

	# Checks that the arguments passed to this function are valid files/directories.
	for i in "$@"
	do
		[[ ! -f "$i" && ! -d "$i" ]] && echo "Invalid file/directory: \"$i\"\nExiting..." \
			&& exit 1
	done

	# Perform the command based on whichever method is available.
	if [[ $USERM ]]
	then
		rm -rvf "$1" | pv -s $(du -sb "$1" | awk '${print $1}')
	elif [[ $USERSYNC ]]
	then
		mkdir empty_dir
		rsync -av --stats --human-readable --delete empty_dir/ "$1" \
			| pv -s $(du -sb "$1" | awk '${print $1}')
		rm -r empty_dir
	#elif [[ -z $USERSYNC && -z $USERM ]]
	fi

}

# Simple function to remove ANSI Escape code colors.
# Useful for when piping output of a command into another command like sed or grep and both of those
# commands take the literal text output (including ANSI escape codes that display in the terminal as
# colored or stylized text, but in the program examples listed above, the escape codes are
# interpreted literally).
function nocolor(){
	# Uses /dev/stdin to read from standard input.
	if (( $# == 0 ))
	then
		'sed "s/\x1b\[[0-9;]*m//g"' < /dev/stdin
	else
		'sed "s/\x1b\[[0-9;]*m//g"' <<< "$1"
	fi
}

# Upgrading the "k9" alias from the aliasrc file to be an actual function so that if non-strictly
# numerical input(s) are provided, it will find the PID of the provided program and prompt for
# user-input whether or not to kill the process.

# Simple function to determine if it is being called either being used as a pipe or running as a
# function with arguments (programs/processes) to kill every instance of from the output of ps aux.
function k9a(){
	# Pure POSIX shell method to check if this function is being piped STDOUT from another
	# program or not.
	[[ -p /dev/stdin ]] && PIPEDINPUT=1
	[[ "$PIPEDINPUT" ]] && INPUT=$(</dev/stdin) && echo "$INPUT" | awk 'NR>1{print $2}' | \
		sudo xargs kill -9 && exit 0
	sudo ps aux | grep -v grep | grep -i "$1" | awk '{print $2}' | xargs sudo kill -9
}

# Simple function to update python modules installed via the python-pip python package installer, as
# well as upgrade the pip command itself. The only reason this is a function rather than an alias is
# to be able to both upgrade the pip package installer itself as well as upgrade all pip packages,
# and an alias would be too verbose.
pipup(){
	# Upgrades the pip program.
	/usr/bin/env python3 -m pip install --upgrade pip
	# Checks for outdated pip/python packages
	/usr/bin/env python3 -m pip list --outdated --format=freeze | \
		grep -v '^\-e' | cut -d = -f 1 | xargs -n1 pip3 install -U
}

# Function used when there exists a protected network namespace created via the "namespaced-openvpn"
# script to create a tun0 tunnel network interface and a network namespace connected to it; and this
# function allows for commands to be run through that network namespace (aka, through the VPN
# tunnel) selectively and explicitly, while all other traffic (unless specified) is routed via the
# default/main active network interface.
# This function will execute any program specefied by "$@" options in the "protected" network
# namespace.
function netns-exec(){
	# This just is a placeholder for the OpenVPN config file (using Torguard [All Servers]
	# currently).
	#	local OVPNFILE="/etc/openvpn/client/Torguard/Torguard-ALL_SERVERS-USA.ovpn"

	# This will remove the default "protected" sudo network namespace.
	#	[[ "$(sudo ip netns del $(sudo ip netns list | grep -i "(id: 0)"))" ]] 
	#	[[ "$(sudo ip netns list | grep -i '(id: 0):')" ]] && \
	#	sudo ip netns del $(sudo ip netns del $(sudo ip netns list | grep -i "(id: 0)"))
	sudo ip netns exec protected sudo -u "$USER" "$@"
	#	sudo ip netns exec protected sudo -u "$USER" -E "$@"
	#
	#	 sudo /usr/local/sbin/namespaced-openvpn --config \
	#		/etc/openvpn/client/Torguard/Torguard-ALL_SERVERS.ovpn \
	#	 	--writepid /var/run/openvpn-protected-foo-"$USER".pid \
	#	 	--log /var/log/openvpn-protected-foo-"$USER".log --daemon
}

# [First and foremost, this function "combines" the usage of this function declaration and/or a
# script located in the current $USER "~/.local/bin/" directory--assuming that directory is already
# included in the $PATH env variable path for the $USER--and if the file is not present, then
# execute the "backup" or "fallback" version in this script (which is more limited and does not have
# the same options/functionality as the script does; this is done to conserve on efficiency and load
# time when opening a new shell session.)]
#
# Changing this previous alias of a piped alias command into a function to allow for optional input
# to change the returning value (generated random passphrase) to have a variable length, and/or
# symbols (instead of strictly alphanumerics)--with the additional option to allow for "special"
# special characters, aka, unicode characters.
function genpass(){

	# Define local variables 
	local CHARLENGTH="$1"
	local CRED='\033[1;38;5;9m'
	local CRE='\033[0m'

	### [Commenting the below check for if a local script exists and use thst since this function is
	### far more fleshed out and exists on any host running my custom dotfiles]
	###
	### Firstly check if there is an actual shell script (located in:
	### [$HOME/.local/bin/ManualScripts/generatepass] directory); and if there is,
	### then just forward the ### arguments this function received to that shell script.
	### 	[[ -f "$HOME/.local/bin/ManualScripts/generatepass" ]] && \
	###		$HOME/.local/bin/ManualScripts/generatepass "$@" | tr -d "="|cut -c -${CHARLENGTH} && \
	###		return 0

	# Verify via regex that the input is only digits (CHANGE THIS LATER WHEN ALLOWING OPTIONS!!!).
	[[ -z "$1" ]] && [[ ! "$1" =~ ^[0-9]+$ ]] && \
		echo -e "Non digits found in input ${CRED}$*${CRE}" && \
		echo -e "Using default ${CRED}${CHARLENGTH}${CRE} character length.\n" && local CHARLENGTH=16
	[[ ! "$1" ]] && echo -e "No input given." && \
		echo -e "Using default ${CRED}${CHARLENGTH}${CRE} char limit.\n"
		local CHARLENGTH=16
	# This line below was needed to actually allow user integer input; otherwise the ${CHARLENTH}
	# variable would permanently default to the pre-determined character limit of 10 in length
	[[ "$1" =~ ^[0-9]+$ ]] && local CHARLENGTH=$1
		#echo -e "Using default ${CRED}10${CRE} character length.\n") || \
		#([[ ! "$1" ]] && echo -ne "No input given, using default ${CRED}10${CRE} char limit.\n") && \
	openssl rand -base64 ${CHARLENGTH} | cut -c -${CHARLENGTH} | tr -d "="

	### [OLD METHOD (ALSO PROBABLY MORE READABLE--BUT NEW METHOD IS "SINGLE LINE" CONDITIONAL)] ###
	#local CHARLENGTH="$1"
	#local CRED='\033[1;38;5;9m'
	#local CRE='\033[0m'
	## Verify via regex that the input is only digits (CHANGE THIS LATER WHEN ALLOWING OPTIONS!!!).
	#[[ "$1" ]] || [[ ! "$1" =~ ^[0-9]+$ ]] && \
	#	echo -e "Non digits found in input ${CRED}$*${CRE}\nUsing default ${CRED}10${CRE}" \
	#	"character length.\n" \
	#	&& local CHARLENGTH=10
	#openssl rand -base64 ${CHARLENGTH}

	#for i in `seq 5`
	#do
	#	local x
	#	x=$((i+1))
	#	echo "$i"
	#	sleep 1
	#done
	#[[ $x -gt 10 ]] && return 0

	# General case statement to get various options to change what type of data/passphrase will be
	# generated.

}

# Instead of aliasing ranger in the aliasrc file, I am doing it here so that I can run a small check
# to ensure that ranger is not opening in a nested session, since the code was not running (probably
# not having taken precedence over the other locations in the $PATH to ranger, or from it being
# aliased).
#
# This also has the very beneficial and convenient functionality of preserving shell command history
# from shells running inside nested ranger sesssions.
function ranger(){
	# Taken from the official ranger github repo; keeps your shell in the same directory ranger was
	# in before quitting.
	# Compatible with ranger 1.4.2 through 1.9.*

	# Automatically change the current working directory after closing ranger
	#
	# This is a shell function to automatically change the current working
	# directory to the last visited one after ranger quits. Either put it into your
	# .zshrc/.bashrc/etc or source this file from your shell configuration.
	# To undo the effect of this function, you can type "cd -" to return to the
	# original directory.
    #temp_file="$(mktemp -t "ranger_cd.XXXXXXXXXX")"
    #ranger --choosedir="$temp_file" -- "${@:-$PWD}"
    #if chosen_dir="$(cat -- "$temp_file")" && \
	#	[ -n "$chosen_dir" ] && \
	#	[ "$chosen_dir" != "$PWD" ]; then
    #    cd -- "$chosen_dir"
    #fi
    #rm -f -- "$temp_file"
	
	#	[[ -z "$RANGER_LEVEL" ]] && \
	#		( \
	#			#[[ "$(/bin/env/bash -c 'command -v ranger')" ]] && \
	#			[[ "$(command -v ranger)" ]] && \
	#				### /* ("$(bash -c '/usr/local/bin/ranger')" "$@") || \ */
	#				"$(/bin/env/bash -c 'command -v ranger')" "$@" \
	#		) || ( [[ -e "$RANGER_LEVEL" ]] && local CURRENTDIR="$(pwd)" && \
	#				exit && \
	#				cd "${CURRENTDIR}" \
	#			)
	#		#exit

    local IFS=$'\t\n'
    local tempfile="$(mktemp -t tmp.XXXXXX)"
    local ranger_cmd=(
        command
        ranger
        --cmd="map Q chain shell echo %d > "$tempfile"; quitall"
    )
    
    ${ranger_cmd[@]} "$@"
    if [[ -f "$tempfile" ]] && [[ "$(cat -- "$tempfile")" != "$(echo -n `pwd`)" ]]; then
        cd -- "$(cat "$tempfile")" || return
    fi
    command rm -f -- "$tempfile" 2>/dev/null

	#[[ -z "$RANGER_LEVEL" ]] && ("$(command -v ranger)" "$@") || { CWD="$(pwd)"; exit && cd "$CWD" }
	#exit

	# [[ -z "$RANGER_LEVEL" ]] && "$(command -v ranger)" "$@" || exit
}
alias r='ranger "$@"'

### [TODO] ###
# Function that takes a file as input specified by the user as "$1" (first argument), strips the
# remaining characters after the final/right-most 




# Function to check if bashtop, btop, or either is installed--just to avoid any potential errors and
# prompt the user that neither program is installed. If one--or both--are installed, then take
# preference over "btop" rather than bashtop, however if it is not installed then use btop instead
# (or use neither program and display a small info/error message instead).
#function BashtopOrBtop(){
#	[[ "$(command -v "btop") ]] 
#}


####################################################################################################
####################################################################################################
####################################################################################################
####################################################################################################
####################################################################################################

# Function for youtube-dl to download YouTube Videos/Music (as well as SoundCloud and other online
# streaming service content). This function's primary reason for existence is to allow for an option
# to set a custom output directory of the file(s) with an: "[-o|--output]" option with a supplied
# argument (if no argument--a.k.a. directory--is supplied after the [-o|--output] option, the
# download directory will be set to the current directory ($PWD)).
#	function ytdl(){
#		while :; do
#			case $1 in
#				-op|-ou|--output)
#					shift 1 # Shifts the options backwards by 1.
#					[[ "$1" =~ ^\.*? ]] && DIRECTORY="$(cd "$1" ; pwd)" && break
#					[[ -d "$1" ]] && DIRECTORY="$1" && break
#					[[ -z "$1" ]] && invalidDir="[NULL]" || invalidDir="$1" &&
#					echo -e "\nInvalid directory at: '$invalidDir'..." \
#					"\nUsing the '\$PWD' (\"$PWD\") instead.\n" && DIRECTORY="`pwd`" && break
#					#echo -e "Invalid directory at: \"$1\"...\n" \
#						#"Using the '\$PWD' (\"$PWD\") instead.\n"
#					;;
#				'')
#					DIRECTORY="$DEFAULT"
#					#echo "$DIRECTORY"
#					break
#					;;
#				*)
#					echo -e "\nInvalid option given...\n"
#					usage
#					exit 0
#					;;
#			esac
#			shift
#		done
#	}

####################################################################################################

# being passed, then the directory
## Function to download YouTube Music/Videos, Soundcloud, etc. via youtube-dl utility.
#	ytdl(){
#		# Checks for arguments passed to function. Exit if none.
#		[[ -z "$@" ]] && echo "No arguments or links specified. Exiting..." && return 1
#
#		# Defines regex to variable to verify a proper URL link.
#		local REGEXRULES='(https?|ftp|file)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]'
#		if [[ "$1" =~ [-m|--music] ]]
#		then
#			local CFGDIR="~/.config/youtube-dl/mconfig"
#		elif [[ "$1" =~ [-v|--video] ]]
#			local CFGDIR="~/.config/youtube-dl/config"
#		elif [[ -z "$1" ]] 
#			echo "Defaulting to Video-download mode..."
#			sleep 2
#			local CFGDIR="~/.config/youtube-dl/config"
#		elif [[ "$1" =~ $REGEXRULES ]]
#			local SKIP=1
#			echo "Defaulting to Video-download mode..."
#			sleep 2
#			local CFGDIR="~/.config/youtube-dl/config"
#		else
#			echo
#			echo "Invalid function argument given."
#			echo "Available options are: [-m|--music] or [-v|--video]"
#			echo
#			echo "[Optionally include URLs encapsulated in quotation marks]"
#			echo "[If no URL(s) are specified, a while loop will run where you can input each link]"
#			return 1
#		fi
#
#		# If the SKIP variable is set, that means that straight URL's have been passed to the
#		# function, and will exclude the first parameter/argument; otherwise the LINKLIST array
#		# will be set to skip the first element in the argument-list ("$@").
#		LINKLIST=("${@:1}")
#		[[ $SKIP == 1 ]] && local LINKLIST=("${@:2}")
#
#		# If only one function parameter is passed without any URLs, this while loop will accept
#		# input from the user and every space will be treated as a delimiter and each entry will be
#		# added as a string to LINKLIST.
#		if [[ "$#" -le 1 ]]
#		then
#			echo "Please enter the URL(s) of the Links you would like to download, each URL seperated by a space.\n[Press <Enter> key when finished]:\n"
#			while :;
#			do
#
#
#
#		# Loop that downloads every link provided in arguments after 
#		youtube-dl --config-location "$CFGDIR"
#	}

####################################################################################################

# Function to open a new file in /tmp/ directory, uses the first argument as the filename under
# /tmp/ directory, if the argument is a file that already exists, return a warning and append a
# number to the end.
#	tmpba(){
#		local TMPBASH='/tmp/bashscripts/'
#		[[ ! -d "${TMPBASH}" ]] && read -r -n 1 "$(echo -e "${CR}No directory: " \
#			\"${CB}${TMPBASH}${CR}\" exists.\nWould you like to create it now: [Y/n]: " )" CHOICE
#		[[ -e "$CHOICE" && ! "$CHOICE" =~ '[y|Y|n|N]' ]] && echo "Invalid choice. Exiting..." \
#			&& return 1
#		#if [ -f "$1" ]
#		#then
#		#	echo "File exists. Would you like to overwrite it or 
#		#	while ;:
#		#	do
#
#		#"$EDITOR" -c "bh"
#	}

####################################################################################################

# Reconnects to running tmux session; if multiple sessions found, list them and prompt for input on
# which to connect to.
#	Broken for right now. Will fix later.
#tmr(){
#	#tmux attach-session
#	tsessions="$(tmux list-session | wc -l )"
#	if [ "$tsessions" -gt 1 ]
#	then
#		tnum=0
#		while [[ ! $tnum =~ ^[0-9]{1,} || $tnum -lt $tsessions ]]
#		do
#			echo -e "${CR}There are multiple tmux sessions.${CRE}"
#			tmux list-sessions
#			echo -ne "${CR}Select which to attach to: ${CG}"
#			read tnum
#			echo
#			echo -e "${CR}Invalid Option: ${CBBL}$tnum${CRE}"
#		done
#		tmux attatch-session -t $tnum
#	fi
#}
